##<center>Automated Partitioning of Android Application for TEE##
###Abstract###
 当前的移动设备应用鱼龙混杂，为了提升某些应用的安全性，ARM的TrustZone可以将这些应用放在一个安全的空间中执行。本文将自动的区分出那些应用是需要安全增强的.
###introduction###
当前移动设备都支持第三方应用，这些应用中的安全漏洞给了黑客以窃取用户信息的途径。为了解决这个问题，ARM的TrustZone机制能够在与原有的android内核共享一个硬件平台的情况下，提供了一个安全增强的可信执行环境。但是现有的android应用很少能直接运用该技术，另外，也很难区分出那些是需要保护的数据。

这篇文章在预先标记好重要数据来源的前提下，采用污点分析的方法，找到与该重要数据操作有关的语句，并把他们放到TrustZone中执行，从而达到保护重要数据，增强安全性的目的。
###OverView###
在提取与重要数据相关的语句的时候要遵循两个重要的原则，第一是提取的TCB要尽可能的小（TEE有空间大小限制，减少TEE与普通空间的数据交互），第二是要保留原有的语义结构。

 1. 确定重要数据的source；
 2. 采用污点分析方法（这里采用了FlowDroid）产生程序的CFG，并查找所有与重要数据相关的statement；
 3. 通过对这些statement进行整合，对原有的程序进行重构。

在执行的过程中为了保证TCB尽可能的小，本文只将对重要数据进行修改的语句放入到TEE中执行，而对于只访问但是未进行修改重要数据的语句视为非重要语句，不再提取到TEE中。

同时在本文中也考虑了某些无法将重要语句提出出来的特殊情况，例如程序段过多的依赖于OS, 过多的依赖于重要数据的条件判断等。

下图详细的展示了该算法的执行过程：
![ha](file:///home/xiang/workspace/record/security/paper/image/tz_1.png)

###Partitioning Framework###
如上文所述，我们首先需要确定污点（重要）数据的来源，需要注意的是这些污点数据的来源并不一定是单一的。为了更好的描述污点操作语句与污点之间的关系，定义了一个tag t[source, successor,type]其中source描述传入该语句的污点变量，successor描述了传出的污点变量，而type描述的污点的操作类型。对于一个statement可能存在不只一个数据来源和数据去向，所以为每个statement设置一个集合T。另外为了保证上下文的敏感性，使用D(m)表示方法 m 的上下文，描述了能到达该语句的所有路径（来源）。在进行划分的时候，提取该statement的上下文，如果存在D=>t属于T，则说明该statement涉及敏感数据操作，成为敏感语句候选。<br />
对于候选的敏感语句，我们需要分别向前和向后追踪。对于向前追踪，只需要沿着调用关系图执行就可以，即按照函数调用进行遍历。而对于向后追踪，我们关注将污点数据存入堆中的情况。另外需要考虑的还有函数的返回和全局变量的赋值，这些情况也需要我们进行考虑。<br />
为了区分该statement是否对污点数据进行了修改，我们需要对语句类型进行判断。并将以下几种情况视为privileged

 1. 算数表达式，位操作
 2. 数组操作（可能是为了向后追踪）
 3. 条件判断（由于涉及到污点数据的判断语句必须采用真实的值进行判断，所以必须放到TEE空间中执行）

###TEE Command creation by grouping###
上文中提到，提取TEE Command的两个原则是 1 覆盖所有的重要语句（privileged） 2最小化TEE和normal world的通信。为此，在本文中首先将所有的privileged statement视为单独的Cammand，然后将每个方法中的statement封装为一个整体。另外，为了保证原始语义，如果两条statement之间存在判断语句（这可能会改变程序的执行路径），我们不能把这两条statement进行整合。
