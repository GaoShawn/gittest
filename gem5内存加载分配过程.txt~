最近在研究基于NVM和DRAM的混合内存的cache管理策略，既然要研究混合内存的管理，那么关于操作系统中内存的分配策略就成了最先要了解的东西。由于实验环境使用gem5模拟器来进行，所以就先来考虑gem5内存分配的过程。
首先考虑加载原程序的过程，负责加载原程序的代码位于base/loader文件夹中。我们以elf_file为例。其中包含了symbols，section等的加载过程。其中section调用其父类object_file的loadSection方法，将date，bss，text段加载到内存中。加载过程最终调用portProxy的writeBlob函数，而这个portProxy后来被Se_translating_port_proxy继承，如果在SE模式下运行的时候最终调用tryWriteDramBlob函数，在这个函数中通过process->allocateMem(）进行真正的内存分配。在内存分配完成后调用pTable->translate进行页表的创建和映射。
process在allocateMem中调用了system的allocPhysPages方法来分配真实物理内存。关于分配的过程采用的是clock的方式，在内存管理器中有一个head——dramLocation;每次请求物理内存都以这个head作为起点开始扫描连续的n个物理页，当扫描到结尾的时候再次将head指向DRAM的启始地址。当head再次到达开始扫描的位置的时候返回错误，表明此时没有足够的物理内存可以分配。

下面看看堆是如何分配的，在操作系统中当堆的物理空间不足的时候，需要通过brk函数向操作系统申请物理页。这个函数在gem5的Syscall_emul类中模拟，brkFunc完成了物理空间的申请。
关于栈的申请，由于在进程初始化的时候已经确定了栈的大小，栈都有其对应的虚拟地址。当进程访问某一个栈空间（pTable的lookup函数）发生缺页异常的时候，就会分配一个新的物理页。其中缺页异常的处理程序位于process文件的fixupStackFault函数中，先判断当前的虚拟地址的范围，以确定是否分配真正的物理页。
